package com.hejwesele.realtimedatabase

import com.google.firebase.database.ktx.database
import com.google.firebase.ktx.Firebase
import javax.inject.Inject
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine
import kotlin.reflect.KClass

class FirebaseRealtimeDatabase @Inject constructor() {
    private val root = Firebase.database.reference

    suspend fun <T : Any> read(path: String, type: KClass<T>): FirebaseRealtimeDatabaseResult<T> = suspendCoroutine { continuation ->
        root.child(path).get()
            .addOnSuccessListener { snapshot ->
                val result = when (val item = snapshot.getValue(type.java)) {
                    null -> error("No item of type $type found in Firebase Realtime database under $path")
                    else -> success(item)
                }
                continuation.resume(result)
            }
            .addOnFailureListener {
                continuation.resume(error("Failed retrieving data of type $type from path $path"))
            }
    }

    suspend fun <T : Any> write(path: String, item: T): Boolean = suspendCoroutine { continuation ->
        val key = createNewEntry(path)
        val result = key?.let {
            val reference = root.child("$path$it")
            item.addId(it)
            reference.setValue(item).isSuccessful
        } ?: false

        continuation.resume(result)
    }

    suspend fun <T> update(path: String, item: T): Boolean = suspendCoroutine { continuation ->
        val result = root.child(path).setValue(item)

        continuation.resume(result.isSuccessful)
    }

    suspend fun delete(path: String): Boolean = suspendCoroutine { continuation ->
        val result = root.child(path).removeValue()

        continuation.resume(result.isSuccessful)
    }

    private fun createNewEntry(path: String): String? {
        return root.child(path).push().key
    }

    private fun <T : Any> T.addId(id: String) {
        this::class.java.declaredFields
            .firstOrNull { field ->
                field.isAnnotationPresent(AutoGeneratedId::class.java)
            }?.let { field ->
                if (field.type.isAssignableFrom(String::class.java)) {
                    field.isAccessible = true
                    field.set(this, id)
                } else {
                    throw IllegalArgumentException("Only property of type String can be declared as @AutoGeneratedId.")
                }
            }
    }
}
